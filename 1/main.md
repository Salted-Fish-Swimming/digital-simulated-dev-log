# 数字电力模拟

## 为什么要做

我曾在学习数字电路的课程时，梦想做一个数字电路模拟程序，
用来模拟那些课堂上学到的数字电路。
当时我还未曾听过数字电路模拟程序这个名字，
后来在学习计组的时候了解到一款叫做 `Quartus` 的软件。
但这是一款用于开发 FPGA 和 CPLD 的软件，
并不能很好的完成数字电路和计组教具的任务。

后来又了解到了 `logisim` 这款用 java 编写的模拟软件，
它的设计之初的目的就是用作数电的教学工具。
虽然开发者当初选择 java 就是希望它能有一定的跨平台能力，
但随着计算机技术的发展导致的软件兼容性问题，
使得现在它的一些功能已经无法在 win10 上正常运行了。

如果一定要在现在选择一个跨平台的开发平台的话，web 浏览器平台是最合适的平台，
不管是三大操作系统 `windows` `linux` `macos` ，
还是手机的操作系统，只要是符合web浏览器规范的软件，就能正常工作。

基于 web 浏览器平台的模拟器有非常多，比如：

- [OpenCircuits](https://github.com/OpenCircuits/OpenCircuits)
- [Circuits](https://github.com/marcielbp/Circuits)
- [LogiJS](https://github.com/SimonBuxx/LogiJS)
- [Logic-Circuit-Simulator](https://github.com/saliherdemk/Logic-Circuit-Simulator)

但他们其中存在有一些缺点：

- 无法模拟延时门，也就无法模拟可调频的时钟电路
- 线的链接不美观，不横平竖直
- 多位线和单位线无法区分，多位线之间难以区分
- 缺少模块化功能，没有办法把复杂的电路作为一个模块去使用
- 没有 native 的组件接口，没法使用编程语言去扩展组件库
- 快捷键操作不灵活，鼠标操作费时费力

为了解决以上问题，有必要做一个新的 **基于 web 浏览器的数字电路模拟器**

## 设计

简单分析，这个软件由两个大的功能部分组成：

1. 创建/编辑 电路
2. 模拟/调试 电路

### 创建/编辑 电路

想要模拟调试电路，首先需要创建电路，想要创建电路，
则首先要要设计电路结构在计算机中的存储方式。

对于数字电路而言，则由基本的数字电路和连接线组成。

#### 逻辑门/信号线

对于这个模拟器而言，创建和编辑需要在一个 UI 界面上进行，
但 UI 层的电路信息对于模拟和描述一个电路是过剩的，
所以需要分成 `逻辑层` 和 `视图层` 单独讨论。

##### 逻辑层

基本的数字逻辑门包括：

- 非门
- 或门
- 与门

只需要 与非门 就可以造出以上三个个基本逻辑门，
只需要以上三个逻辑门，就可以制造绝大多数数字逻辑电路。

但只有基础的数字逻辑门还无法完成一些其他的功能，
比如线与和线或，比如震荡电路。
为了实现这些功能，有必要添加以下两个基本原件：

- 延迟门 ( 和非门构成一个振荡器 )
- 三态门 ( 做收数字信号控制的高阻态输出 )

模拟电路时，主要考虑的是器件之间链接的拓扑结构。
那么就有几个主要的考虑方向：

- 器件是否带有输入输出的方向性？
- 线路是否具有输入输出的方向性？
- 线路信号改变时，扇出的几个模块的信号更新顺序如何确定？

以上这三点直接涉及到了电路状态的更新算法如何设计，
针对以上三个问题的不同回答，可以设计出多种具有不同性质的模拟算法。

如果这个程序想要模拟一些超出小型规模的电路，
那么需要提供电路模块化的能力。

##### 视图层

逻辑层的电路只设计拓扑链接，即那根信号线链接到那几个电路模块的哪个接口上，
而视图层则要考虑模块和线路在视图中的位置。

对于模块，要考虑它的：

- 大小
- 接口位置
- 试图中的位置
- 图片样式 ( 模块所展示出来的形状 )

对于信号线，则要考虑它的：

- 链接到的模块接口的位置 ( 起始位置和终点位置 )
- 中间转折点的位置
- 信号线的样式

### 调试/模拟 电路

想要调试和模拟已经编辑(导入)好的电路，需要软件内部有一套电路状态的更新算法。
算法设计有好几种思路，为了讨论方便，
这里暂且不讨论在具有模块机制的情况下算法的设计问题。

|            | 无延时门 | 有延时门 |
| ---------- | -------- | -------- |
| 无循环依赖 | 解释执行 | 事件驱动 |
| 有循环依赖 | 状态遍历 | (待定)   |

#### 解释执行: 

如果电路里只有由简单逻辑门构成的DAG式的没有循环依赖的电路，
或者说，这是一个纯粹的组合逻辑电路，那么问题就非常简单，
整个电路可以看作是一个关于输入输出的纯函数，
我们只需要把整个电路当作一个函数进行一次 `eval` 就好。

算法的核心思路就是对电路进行解释执行。

```js
// 伪代码

// 根据电路结构和输入模拟输出
const simulate = (circuit, input) => {
  circuit.map(logate => {
    if (logate is input) { // 如果是电路输入
      const { index } = logate;
      return input[index]; // 直接查找对应的输入值
    } else {
      const { eval, in } = logate; // 直接使用逻辑门本身的计算函数
      return eval(simulate(in, input));
    }
  })
}
```

``` Haskell
-- 用Haskell写伪代码则更简单

data Logate = And Logate Logate
  | Or Logate Logate
  | Not Logate
  | In Int

type Circuit = [ Logate ]

-- 电路模拟算法
simulate :: Circuit -> [Bool] -> [Bool]
simulate circuit input = ($ input) . fn <$> circuit where
  fn (And a b) = (&&) <$> fn a <*> fn b
  fn (Or a b)  = (||) <$> fn a <*> fn b
  fn (Not a) = not <$> fn a
  fn (In i) = (!! i)  -- 读取对应位置的输入

-- 模拟 full adder 在 A=1, B=1, C=0 下的输出
output = simulate fullAdder [ True, True, False ]
```

#### 状态遍历：

如果我们继续尝试用之前的方法模拟一个带有循环依赖的电路的话，
会发现算法会进入死循环。

以一个 RS锁存器 为例：

```
IN : R , S
Out : D , _D

D   := Not(Or(_D,  R))
_D  := Not(Or( D,  S))
```

当我们用之前的方法继续模拟这个电路的话：

1. 欲求 `D` 即求 `_D` 与 `R` ， `R` 已知，即求 `_D`
2. 欲求 `_D` 即求 `D` 与 `S` ， `S` 已知，即求 `D`

解释执行的算法就会在以上两个步骤里不停的循环。

这让我们不得不怀疑，对于一个一半的数字电路，存在一个通用的算法能给出模拟结果吗？
或者说，这是一个图灵停机问题吗？即这个问题是不是不存在一个通用算法来解决它？

我们来看另一个例子：

```
In : A
Out : B

B := Not(And(A, B))
```

当 `A = 1` 时 `B = Not(B)` ，


当我门要模拟的一个电路不是一个无循环依赖的纯粹的组合逻辑电路时，情况就有所不同了。

总所周知，时序逻辑电路具有记忆之前输入的功能的，即时序逻辑电路不是一个纯函数，


#### 事件驱动:

延时门会带来一个新的问题：由于存在延时门，所以一定存在一些电路，
这些电路里的延时门后一段信号线 ( wire ) ，它的状态是不确定的。

比如：

```
In : A
Out : X , Y

X := not(A)
Y := delay<1s>(A)

```

对于第 0s ，`X` 的状态就是 `not(A)` ，而对于 `Y` 的状态就无法确定了，
因为你暂时无法确定 1s 前 `A` 的状态，那自然也无法确定当前 `Y` 的输出状态。


