## 状态遍历：

总所周知，时序逻辑电路具有记忆之前输入的功能的，即时序逻辑电路不是一个纯函数，
如果依然使用之前的解释执行的方式来模拟电路状态的话，可能会出错。

如果我们继续尝试用之前的方法模拟一个带有循环依赖的电路的话，
会发现算法会进入死循环。

以一个 RS锁存器 为例：

```
IN  : R , S
Out : Q , Q'

Q  := Not(Or(Q', R))
Q' := Not(Or(Q,  S))
```

当我们用之前的方法继续模拟这个电路的话：

1. 欲求 `Q` 即求 `Q'` 与 `R` ， `R` 已知，即求 `Q'`
2. 欲求 `Q'` 即求 `Q` 与 `S` ， `S` 已知，即求 `Q`

解释执行的算法就会在以上两个步骤里不停的循环。

可以看到，当我门要模拟的一个电路不是一个无循环依赖的纯粹的组合逻辑电路时，
情况就有所不同了。

当然, 我们可以通过判断

---

这让我们不得不怀疑，对于一个一半的数字电路，存在一个通用的算法能给出模拟结果吗？
或者说，这是一个图灵停机问题吗？或者说这个问题是不是不存在一个通用算法来解决它？

我们来看另一个例子：

```
In : A
Out : B

Wire W = And(A, B)

B := Not(W)
```

当 `A = 1` 时 `B = Not(B)` ，`B` 应该是多少？
如果 `B = 1` 的话，根据 `B = Not(B)`, `B` 应该等于 `0` 。
如果 `B = 0` 的话，根据 `B = Not(B)`, `B` 应该等于 `1` 。

可以看到，并不是每个电路对每个输入都有稳态的。

### 算法停机

我们首先解决第一个问题，即这是不是一个停机问题，即这个问题在有限的时空内有没有解。

- 首先，一条信号线的状态是有限的，即只有 `0` 和 `1` 两种状态。

- 其次，组成一个电路的逻辑原件 ( 逻辑门/信号线 ) 是有限的，
这意味着一个电路可能出现的状态
( 无论合法/非法 ( 我们暂时称为 `DS(digital state)` ) )
也是有限的。

- 最后，我们的状态更新算法实质就是从一个电路可能出现的状态 `DS_1`
转换为另一个可能出现的状态 `DS_2` ( `DS_1 -> DS_2` )，
因为可能的状态是有限的，而游走方式构成的集合是状态集合 ( `{ DS }` ) 的笛卡尔积，
也是有限的。

- 而我们的算法实际上就是在一个有限图上的找到一个合法的游走路径，
使得状态的更新符合逻辑门本身的约束，
寻找这样一条路径或者判断这样的路径是否存在是图灵停机的，
即可以在有限事件内解决这个问题。
因为问题的求解范围是有限的，最坏的情况把整个解空间内的所有路径都暴力搜索一遍，
总可以得到问题的答案。

可以看到，判断一个电路如何演化，并且有没有最终问题是一个图灵停机问题,
我们并没有去尝试解决一个解决不了的问题，这个问题实际上在有限的时空内是有解的。

### 0/1 状态

但这里面实际上有一个问题，模拟算法开始运行前，电路的初始状态是什么样的？

全为 `0` ？还是全为 `1` ？ 还是随机？

还是以上面哪个电路为例，如果全为 `0` ，意味着 ` 0 = Not(0) ` ，
如果全为 `1` ，意味着 ` 1 = Not(1) `，不管每条信号线取什么值，
这个电路总是自相矛盾，这意味着，我们的电路的起始状态总是一个非法的状态。

我们不妨给信号线多添加一个名叫 `X` 的状态，意为这个状态不确定，
即可能是 `0` 又可能是 `1` ，即 `0/1` ，我们按照这个原则，
改写一下几个逻辑门的跟新规则：

|   A   | Not(A) |
| :---: | :----: |
| 0/1/x | 1/0/x  |

|   A   |   B   | And(A, B) |
| :---: | :---: | :-------: |
| 0/1/x |   0   |     0     |
| 0/1/x |   1   |   0/1/x   |
| 0/1/x |   x   |   0/x/x   |

|   A   |   B   | Or(A, B) |
| :---: | :---: | :------: |
| 0/1/x |   0   |  0/1/x   |
| 0/1/x |   1   |    1     |
| 0/1/x |   x   |  x/1/x   |

由于 `X = Not(X)` ，`X = And(X, X)` ，`X = Or(X, X)` ,
所以把所有的信号线的初始状态设置为 `X` 是一件非常合理的事。

### 算法的非确定性

我们尝试用新的方法来模拟一下之前那个简单的单输入，单输出的电路：

```
State :: (Stateof(A), Stateof(W), Stateof(B))

// A 输入为 0
(0, X, X)
(0, 0, X) // 更新 W
(0, 0, 1) // 更新 B
// 最终稳态是 (0, 0, 1)

// A 输入为 1
(1, X, X)
// 最终稳态是 (1, X, X)
```

总所周知，时许电路对信号的输入顺序具有敏感性，即使是相同的输入，
如果交换一下顺序，最终的输出结果也有可能不同，最简单的例子就是 `RS锁存器` 。

```
State :: (Stateof(R), Stateof(S), Stateof(Q), Stateof(Q'))

(0, 1, X, X)
(0, 1, X, X) // 更新 Q
(0, 1, X, 0) // 更新 Q'
(0, 1, 1, 0) // 更新 Q
```

## 事件驱动:

延时门会带来一个新的问题：由于存在延时门，所以一定存在一些电路，
这些电路里的延时门后一段信号线 ( wire ) ，它的状态是不确定的。

比如：

```
In : A
Out : X , Y

X := not(A)
Y := delay<1s>(A)

```

对于第 0s ，`X` 的状态就是 `not(A)` ，而对于 `Y` 的状态就无法确定了，
因为你暂时无法确定 1s 前 `A` 的状态，那自然也无法确定当前 `Y` 的输出状态。
